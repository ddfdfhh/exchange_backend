import { DataSource, EntityManager, Repository } from 'typeorm';
import { Trade } from './trade/trade.entity';
import { OrderBook } from './order_book/order_book.entity';
import { Coin, Wallet } from './wallet/wallet.entity';
import { NetworkFee } from './network_fees/network_fees.entity';
import { Status, Withdrawal } from './withdrawal_entity/withdrawal.entity';
import { SchedulerRegistry } from '@nestjs/schedule';
import { ErrorSave } from './error_handling.entity';
import { Deposit } from './deposit_entity/deposit.entity';
import { User, YesNo } from './user/user.entity';
import { TokenAddressBalance } from './address_balance.entity';
import { Identity } from './identity/identity.entity';
export declare class DatabaseService {
    private tradeRepository;
    private bookRepository;
    private walletRepository;
    private errorRepository;
    private depositRepository;
    private userRepository;
    private tokenAddressBalanceRepository;
    private withdrawalRepository;
    private nwFeesRepository;
    private identityRepository;
    private manager;
    private schedulerRegistry;
    private dataSource;
    constructor(tradeRepository: Repository<Trade>, bookRepository: Repository<OrderBook>, walletRepository: Repository<Wallet>, errorRepository: Repository<ErrorSave>, depositRepository: Repository<Deposit>, userRepository: Repository<User>, tokenAddressBalanceRepository: Repository<TokenAddressBalance>, withdrawalRepository: Repository<Withdrawal>, nwFeesRepository: Repository<NetworkFee>, identityRepository: Repository<Identity>, manager: EntityManager, schedulerRegistry: SchedulerRegistry, dataSource: DataSource);
    getAllTrades(symbol: any, limit: any): Promise<Trade[]>;
    getUserTrades(user_id: any, symbol: any, limit: any): Promise<Trade[]>;
    getPendingWithdrawal(): Promise<Partial<Withdrawal>[]>;
    getPendingDeposits(): Promise<Partial<Deposit>[]>;
    getAllOrders(user_id: number, symbol: string, side: string, limit?: number): Promise<OrderBook[]>;
    getOrderById(id: number): Promise<OrderBook>;
    fetchAllOrdersByUserId(userid: number): Promise<OrderBook[]>;
    getUserOrders(user_id: number, symbol: string, side: string, limit?: number): Promise<OrderBook[]>;
    getUserOrdersNoSide(user_id: number, symbol: string, limit?: number): Promise<OrderBook[]>;
    findOrders(side: string, symbol: string, limit: number, order_by: any): Promise<OrderBook[]>;
    saveTrade(trade: Trade): Promise<Trade>;
    saveError(error: ErrorSave): Promise<ErrorSave>;
    saveOrderBook(order_book: OrderBook): Promise<any>;
    updateOrderBook(id: number, update: any): Promise<any>;
    setCurrentRefreshToken(refreshToken: string, id: number): Promise<any>;
    last_24_hours_data(): Promise<any[]>;
    price_before_24_hour(): Promise<any>;
    getNetworkFees(network: string): Promise<NetworkFee>;
    searchAddress(user_id: number, network: string): Promise<Wallet>;
    todayWithrawn(user_id: number, coin: Coin, network: string): Promise<any>;
    saveAddress(user_id: number, network: string, address: string, privateKey: string): Promise<Wallet>;
    saveWithdrawal(user_id: number, from_address: string, to_address: string, coin: Coin, network: string, with_amount: number, transaction_hash: string, status?: Status, pay_with_admin?: YesNo): Promise<void>;
    saveDeposit(user_id: number, address: string, coin: Coin, network: string, start_block: number): Promise<void>;
    updateWebhookId(transaction_hash: string, hook_id: string, to: string, coin: Coin, network: string): Promise<any>;
    updateWtihdrawalStatus(transaction_hash: string, status: Status): Promise<void>;
    updateWtihdrawalById(id: number, data: Partial<Withdrawal>): Promise<void>;
    updateDepositById(id: number, data: Partial<Deposit>): Promise<void>;
    updateWallet(user_id: number, amount: number, from_address: string, coin: Coin, network: string, toDo: string): Promise<void>;
    checkForPendingDeposit(user_id: number, coin: Coin, network: string, to_address: any): Promise<boolean>;
    findDbWithdrawalSourceAddress(coin: Coin, network: string, amount: number): Promise<boolean | TokenAddressBalance>;
    updateTokenAddressBalance(id: number, amount: any, todo: string): Promise<any>;
    saveTokenAddressBalance(address: string, coin: Coin, network: string, amount: number, todo?: string): Promise<void>;
    findUser(email: string): Promise<User | null>;
    findUserById(id: number): Promise<User | null>;
    saveUser(user: User): Promise<User>;
    removeRefreshToken(userId: number): Promise<import("typeorm").UpdateResult>;
    updateUser(uuid: string, data: Partial<User>): Promise<import("typeorm").UpdateResult>;
    updateUserById(id: any, data: Partial<User>): Promise<import("typeorm").UpdateResult>;
    existUserData(data: Partial<User>): Promise<User>;
    updateIdentity(data: {
        user_id: number;
        front_path: string;
        back_path: string;
        pan: string;
        selfie: string;
        type: string;
        gov_id: string;
        country: string;
        full_name: string;
        address: string;
    }): Promise<void>;
    lastUpdatedTimeListener(): Promise<any>;
    updateListenerTime(): Promise<void>;
    insertInBinanceTradeTablensertInB(user_id: any, clientOrderId: any, price: any, oQty: any, exQty: any, side: any, type: any, status: any, fills: any, symbol: any, orderId: any, cummulativeQuoteQty: any, settled_price: any): Promise<void>;
    updateBinanceTrade(clientOrderId: any, side: any, type: any, newStatus: any, symbol: any, orderId: any, date: any, execQty: any, settled_price: any): Promise<void>;
    updateWalletQuery(q: string): Promise<void>;
    insertEventData(clientOrderId: any, event_date: any, full_event_data: any): Promise<void>;
    getOrderFromTable(orderId: any, user_id: any): Promise<any>;
    getAllUserOrderFromTable(user_id: any): Promise<string>;
    deleteOrder(orderId: any, user_id: any): Promise<void>;
}
